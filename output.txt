File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/.env
PORT=3000
DB_STRING=mongodb+srv://singhsarthakindia:<db_password>@cluster0.jk9dg.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0
DB_PASSWORD=EqYdQWbHDdnMlIug
JWT_SECRET = your_jwt_secret_key 
JWT_EXPIRES_IN = 1d
NODE_ENV = production
EMAIL_USERNAME=singhsarthak.india@gmail.com
BREVO_API_KEY=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

CLOUDINARY_CLOUD_NAME=dslenl5ol
CLOUDINARY_API_KEY=912249823951135
CLOUDINARY_API_SECRET=6kHrEDKRXDPlButmJ_fp--rDm_0

STRIPE_SECRET_KEY=sk_test_51QAGwSRrAZESk3Zu2jfMAfUAXbh99JHLos0Tv9eyVfVSuPpdceEU1z2z2MVFJMv9ZpVjYAdPIw5YojznLopgDEzC00ewf8FUOw
STRIPE_PUBLISHABLE_KEY=pk_test_51QAGwSRrAZESk3ZuTAPV1PPSpu0n2XlBFNhlJB1HpJF4ulm5TNzuTPIDPemyyk8ZH4V345A2XbP4nNGXeN3DUl8H002rDpuYF0

File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/.gitignore
*.env
*.log
node_modules/
.git/

File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/app.js
import express from "express";
import cors from "cors"; // Import CORS
import helmet from "helmet"; // For setting various HTTP headers
import rateLimit from "express-rate-limit"; // For limiting requests
import mongoSanitize from "express-mongo-sanitize"; // To sanitize data
import xss from "xss-clean"; // To prevent XSS attacks
import hpp from "hpp"; // To protect against HTTP parameter pollution
import globalErrorHandler from "./utils/errorHandler.js";
import courseRoutes from "./routes/courseRoutes.js";
import userRoutes from "./routes/userRoutes.js";
import authRoutes from "./routes/authRoutes.js";
import lessonRoutes from "./routes/lessonRoutes.js";
import reviewRoutes from "./routes/reviewRoutes.js";
import enrollmentRoutes from "./routes/enrollmentRoutes.js";
import notFound from './middleware/notFound.js';
import compression from 'compression';
import morgan from "morgan";

const app = express();

// Logger - Use in development mode only
if (process.env.NODE_ENV === "development") {
    app.use(morgan('dev'));
}

// Security Middleware
app.use(helmet()); // Set security HTTP headers
app.use(compression()); // Compress response bodies
app.use(express.json()); // Parse JSON bodies

// Enable CORS with options
app.use(cors());

// Rate Limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 requests per windowMs
});
app.use('/api', limiter); // Apply to all requests starting with /api

// Data Sanitization and Protection
app.use(mongoSanitize()); // Sanitize data against NoSQL query injection
app.use(xss()); // Prevent XSS attacks
app.use(hpp()); // Prevent HTTP Parameter Pollution

// Health Check Endpoint
app.get('/health', (req, res) => {
    res.status(200).json({ status: 'ok', timestamp: new Date() });
});

// Define Routes
app.use("/api/v1/courses", courseRoutes);
app.use("/api/v1/auth", authRoutes);
app.use("/api/v1/users", userRoutes);
app.use("/api/v1/lessons", lessonRoutes);
app.use("/api/v1/enrollments", enrollmentRoutes);
app.use("/api/v1/reviews", reviewRoutes);

// Error Handling
app.use(notFound);
app.use(globalErrorHandler);

export default app;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/config/cloudinary.js
import { v2 as cloudinary } from 'cloudinary';

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// Function to generate signed URLs
export const generateSignedUrl = (publicId, expiresIn) => {
  return cloudinary.video(publicId, {
    sign_url: true,
    expire_at: Math.floor(Date.now() / 1000) + expiresIn, // Expiration time in seconds
  });
};

export default cloudinary;

File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/controllers/authController.js
import User from "../models/User.js";
import jwt from "jsonwebtoken";
import catchAsync from "../utils/catchAsync.js";
import AppError from "../utils/AppError.js";
import { sendWelcomeEmail, sendResetPasswordEmail } from "../utils/emailService.js";
import crypto from 'crypto';

const signToken = (userId) => {
  return jwt.sign({ userId }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN,
  });
};

// Forgot Password
export const forgotPassword = catchAsync(async (req, res, next) => {
  const { email } = req.body;
  const user = await User.findOne({ email });

  if (!user) {
    return next(new AppError("There is no user with that email address.", 404));
  }

  // Check the number of attempts
  if (user.passwordResetAttempts >= 3) {
    return next(new AppError("You have exceeded the maximum number of password reset attempts. Please try again later.", 429));
  }

  // Generate reset token using the model method
  const resetToken = user.createPasswordResetToken();
  await user.save({ validateBeforeSave: false });
  const resetUrl = `${req.protocol}://${req.get('host')}/api/v1/resetPassword?token=${resetToken}`;

  // Send email with reset token
  await sendResetPasswordEmail(email, resetUrl);

  // Increment the password reset attempts
  user.incrementPasswordResetAttempts();
  await user.save({ validateBeforeSave: false });

  res.status(200).json({
    status: "success",
    message: "Reset token sent to email!",
  });
});

// Reset Password
export const resetPassword = catchAsync(async (req, res, next) => {
  const { password, passwordConfirm } = req.body;
  const { token } = req.query;

  // Find the user with the hashed reset token
  const user = await User.findOne({ passwordResetToken: { $exists: true } });

  // Check if the user exists and if the reset token is valid
  if (!user || !user.isResetTokenValid(token)) {
    return next(new AppError("Token is invalid or has expired.", 400));
  }

  // Check password confirmation
  if (password !== passwordConfirm) {
    return next(new AppError("Passwords do not match", 400));
  }

  // Update password and clear reset token fields
  user.password = password; // The password will be hashed in the pre-save hook
  user.passwordResetToken = undefined;
  user.passwordResetExpires = undefined;

  // Reset password reset attempts after a successful reset
  user.resetPasswordAttempts();
  await user.save(); // Save the new password

  // Send a success response
  res.status(200).json({
    status: "success",
    message: "Password has been reset successfully!",
  });
});

// Signup
export const signup = catchAsync(async (req, res, next) => {
  const { name, email, password, contact, passwordConfirm } = req.body;

  const existingUser = await User.findOne({ email });
  if (existingUser) {
    return next(new AppError("Email already in use", 400));
  }

  if (password !== passwordConfirm) {
    return next(new AppError("Password and passwordConfirm do not match", 400));
  }

  const user = new User({ name, email, contact, password });
  await user.save();

  const token = signToken(user._id);
  
  await sendWelcomeEmail(email, name);

  res.status(201).json({
    message: "User registered successfully",
    token,
    user: { id: user._id, name: user.name, email: user.email },
  });
});

// Login
export const login = catchAsync(async (req, res, next) => {
  const { email, password } = req.body;

  const user = await User.findOne({ email }).select("+password");
  if (!user) {
    return next(new AppError("Incorrect email or password", 401));
  }

  const isPasswordCorrect = await user.correctPassword(password, user.password);
  if (!isPasswordCorrect) {
    return next(new AppError("Incorrect email or password", 401));
  }

  const token = signToken(user._id);

  res.status(200).json({
    status: "success",
    token,
    user: { id: user._id, email: user.email },
  });
});


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/controllers/courseController.js
import Course from "../models/Course.js";
import AppError from "../utils/AppError.js";
import catchAsync from "../utils/catchAsync.js";
import Enrollment from "../models/Enrollment.js";
import Review from "../models/Review.js";
import Lesson from "../models/Lesson.js";

// @desc Create a new course
// @route POST /api/v1/courses
export const createCourse = catchAsync(async (req, res, next) => {
  const { title, description, instructors, category, lessons } = req.body;

  // Map instructor IDs to objects with _id (required by schema)
  const instructorsWithId = instructors.map((instructorId) => ({
    _id: instructorId,
  }));

  // Create the course with mapped instructor objects
  const newCourse = await Course.create({
    title,
    description,
    instructors: instructorsWithId,  // Now it's an array of objects with _id.
    category,
    lessons: lessons || [],
    createdBy: req.user._id,
  });

  res.status(201).json({
    success: true,
    data: newCourse,
  });
});

// @desc Update course details
// @route PATCH /api/v1/courses/:id
export const updateCourse = catchAsync(async (req, res, next) => {
  const course = await Course.findById(req.params.id);

  if (!course) {
    return next(new AppError("Course not found", 404));
  }

  // Check if the user is the creator, an instructor, or an admin
  const isCreator = course.createdBy.toString() === req.user._id.toString();
  const isInstructor = course.instructors.some(
    (instructor) => instructor._id.toString() === req.user._id.toString()
  );
  const isAdmin = req.user.role === 'admin';

  if (!isCreator && !isInstructor && !isAdmin) {
    return next(new AppError("You do not have permission to update this course", 403));
  }

  const allowedFields = [
    "title",
    "description",
    "lessons",
    "category",
    "instructors",
  ];

  // Filter out only the allowed fields from the request body
  const updateFields = Object.keys(req.body)
    .filter((key) => allowedFields.includes(key))
    .reduce((obj, key) => {
      obj[key] = req.body[key];
      return obj;
    }, {});

  // Update course fields manually
  Object.keys(updateFields).forEach((field) => {
    course[field] = updateFields[field];
  });

  // If instructors are being updated, map them to the correct structure
  if (updateFields.instructors) {
    course.instructors = updateFields.instructors.map((instructorId) => ({
      _id: instructorId,
    }));
  }

  // Save the updated course
  const updatedCourse = await course.save();

  res.status(200).json({
    success: true,
    data: updatedCourse,
  });
});

// @desc Delete a course
// @route DELETE /api/v1/courses/:id
export const deleteCourse = catchAsync(async (req, res, next) => {
  const course = await Course.findById(req.params.id);

  if (!course) {
    return next(new AppError("Course not found", 404));
  }

  // Check if the user is the creator or an admin
  const isCreator = course.createdBy.toString() === req.user._id.toString();
  const isAdmin = req.user.role === 'admin';

  if (!isCreator && !isAdmin) {
    return next(new AppError("You do not have permission to delete this course", 403));
  }

  // Proceed with course deletion
  await course.remove();
  await Lesson.deleteMany({ course: req.params.id });
  await Review.deleteMany({ course: req.params.id });
  await Enrollment.deleteMany({ course: req.params.id });

  res.status(200).json({
    success: true,
    message: "Course, associated lessons, reviews, and enrollments deleted successfully",
  });
});

// @desc Get all courses with filtering and pagination
// @route GET /api/v1/courses
export const getCourses = catchAsync(async (req, res, next) => {
  const { category, page = 1, limit = 10 } = req.query;

  // Modify the query to make the category search case-insensitive
  const query = category ? { category: { $regex: new RegExp(category, "i") } } : {};

  const courses = await Course.find(query)
    .limit(parseInt(limit))
    .skip((page - 1) * limit)
    .populate("instructors._id", "name email") // Populate instructors
    .populate("lessons", "title duration"); // Populate lessons

  // Format instructors to match desired structure
  const formattedCourses = courses.map((course) => ({
    _id: course._id,
    title: course.title,
    description: course.description,
    instructors: course.instructors.map((instructor) => ({
      _id: instructor._id._id, // Access the instructor's _id from the populated _id
      name: instructor.name || instructor._id.name, // Ensure name is included
      email: instructor._id.email, // Access the email from the populated _id
    })),
    category: course.category,
    lessons: course.lessons,
    rating: course.rating,
    createdAt: course.createdAt,
    updatedAt: course.updatedAt,
  }));

  res.status(200).json({
    success: true,
    count: formattedCourses.length,
    data: formattedCourses,
  });
});

// @desc Get a single course by ID
// @route GET /api/v1/courses/:id
export const getCourseById = catchAsync(async (req, res, next) => {
  const course = await Course.findById(req.params.id)
    .populate("instructors._id", "name email") // Populate instructors
    .populate("lessons", "title duration");

  if (!course) {
    return next(new AppError("Course not found", 404));
  }

  // Format instructors correctly
  const formattedInstructors = course.instructors.map((instructor) => ({
    _id: instructor._id._id, // Access the instructor's _id from the populated _id
    name: instructor.name || instructor._id.name, // Ensure name is included
    email: instructor._id.email,
  }));

  const responseData = {
    _id: course._id,
    title: course.title,
    description: course.description,
    instructors: formattedInstructors,
    category: course.category,
    lessons: course.lessons,
    rating: course.rating,
    createdAt: course.createdAt,
    updatedAt: course.updatedAt,
  };

  res.status(200).json({
    success: true,
    data: responseData,
  });
});


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/controllers/enrollmentController.js
import Enrollment from "../models/Enrollment.js";
import catchAsync from "../utils/catchAsync.js";
import AppError from "../utils/AppError.js";
import User from "../models/User.js";
import Course from "../models/Course.js";
import { sendEnrollmentEmail } from "../utils/emailService.js";

// @desc Enroll a student in a course
// @route POST /api/v1/enrollments
export const enrollInCourse = catchAsync(async (req, res, next) => {
  const { course } = req.body;
  
  // Check if the student is already enrolled in the course
  const existingEnrollment = await Enrollment.findOne({
    course,
    student: req.user.id
  });

  if (existingEnrollment) {
    return next(
      new AppError("Student is already enrolled in this course", 400)
    );
  }

  const enrollment = await Enrollment.create({
    course,
    student: req.user.id
  });

  const curCourse = await Course.findById(course); 
  const curUser = await User.findById(req.user.id); 

  await sendEnrollmentEmail(curUser.email, curCourse.title,curCourse.id, curUser.name);
  
  res.status(201).json({
    success: true,
    data: enrollment,
  });
});

// @desc Get enrollment by ID
// @route GET /api/v1/enrollments/:id
export const getEnrollmentById = catchAsync(async (req, res, next) => {
  const enrollment = await Enrollment.findById(req.params.id)
    .populate("student", "name email")
    .populate("course", "title description");

  if (!enrollment) {
    return next(new AppError("Enrollment not found", 404));
  }

  res.status(200).json({
    success: true,
    data: enrollment,
  });
});

// @desc Get all enrollments by student ID
// @route GET /api/v1/enrollments/student/:studentId
export const getEnrollmentsByStudent = catchAsync(async (req, res, next) => {
  const enrollments = await Enrollment.find({ student: req.params.studentId })
    .populate("course", "title description")
    .populate("student", "name email");

  res.status(200).json({
    success: true,
    count: enrollments.length,
    data: enrollments,
  });
});

// @desc Get all enrollments for a course
// @route GET /api/v1/enrollments/course/:courseId
export const getEnrollmentsByCourse = catchAsync(async (req, res, next) => {
  const enrollments = await Enrollment.find({ course: req.params.courseId })
    .populate("course", "title description")
    .populate("student", "name email");

  res.status(200).json({
    success: true,
    count: enrollments.length,
    data: enrollments,
  });
});

// @desc Delete an enrollment
// @route DELETE /api/v1/enrollments/:id
export const deleteEnrollment = catchAsync(async (req, res, next) => {
  const enrollment = await Enrollment.findByIdAndDelete(req.params.id);

  if (!enrollment) {
    return next(new AppError("Enrollment not found", 404));
  }

  res.status(200).json({
    success: true,
    message: "Enrollment deleted successfully",
  });
});


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/controllers/lessonController.js
import Lesson from "../models/Lesson.js";
import AppError from "../utils/AppError.js";
import catchAsync from "../utils/catchAsync.js";
import Course from "../models/Course.js";
import Enrollment from "../models/Enrollment.js";
import { generateSignedUrl } from './../config/cloudinary.js';
import cloudinary from "./../config/cloudinary.js"; 

// Helper function to check if the user is an instructor
const isInstructor = (course, userId) => {
  return course.instructors.some(instructor => instructor._id.toString() === userId.toString());
};

// Helper function to check if the user is the course creator
const isCourseCreator = (course, userId) => {
  return course.createdBy.toString() === userId.toString();
};

// Helper function to check if the user is an admin
const isAdmin = (user) => {
  return user.role === "admin"; // Assuming user role is stored in the user object
};

// @desc Create a new lesson
// @route POST /api/v1/lessons

// Create a new lesson
export const createLesson = catchAsync(async (req, res, next) => {
  const { title, content, duration, course } = req.body;

  const foundCourse = await Course.findById(course);
  if (!foundCourse) {
    return next(new AppError("Course not found", 404));
  }

  // Check if the user is authorized (Admin, Instructor, or Course Creator)
  if (!isAdmin(req.user) && !isInstructor(foundCourse, req.user.id) && !isCourseCreator(foundCourse, req.user.id)) {
    return next(new AppError("You are not authorized to create lessons for this course", 403));
  }

  // Ensure the video is uploaded by multer middleware
  if (!req.file) {
    return next(new AppError("Please upload a video file", 400));
  }

  // Extract the video URL from the multer object
  const videoUrl = req.file.path;

  // Create the new lesson with the video URL
  const newLesson = await Lesson.create({
    title,
    content,
    duration,
    videoUrl,
    course,
  });

  // Update the course with the new lesson
  await Course.findByIdAndUpdate(
    course,
    { $addToSet: { lessons: newLesson._id } },
    { new: true, runValidators: true }
  );

  res.status(201).json({
    success: true,
    data: newLesson,
  });
});

// @desc Get a single lesson by ID
// @route GET /api/v1/lessons/:id
export const getLessonById = catchAsync(async (req, res, next) => {
  const lesson = await Lesson.findById(req.params.id).populate({
    path: 'course',
    select: 'title instructor',
  });

  if (!lesson) {
    return next(new AppError("Lesson not found", 404));
  }

  // Check if the user is an admin
  const isAdmin = req.user.role === "admin";

  // If the user is not an admin, check if they are enrolled in the course
  if (!isAdmin) {
    const enrollment = await Enrollment.findOne({
      student: req.user.id,
      course: lesson.course._id,
    });

    if (!enrollment) {
      return next(new AppError("You are not enrolled in this course", 403));
    }
  }

  // Extract the public ID from the video URL using the same logic as in updateLesson
  const oldVideoUrl = lesson.videoUrl;

  // Use regex to extract the public ID
  const publicIdMatch = oldVideoUrl.match(/upload\/v\d+\/(.*)\.mp4$/);
  
  if (!publicIdMatch) {
    return next(new AppError("Invalid video URL", 400));
  }

  const publicId = publicIdMatch[1]; // Extracts the public ID without extension
  console.log(`Extracted Public ID for signed URL: ${publicId}`); // Log public ID for debugging

  // Generate a signed URL for the video
  const signedVideoUrl = generateSignedUrl(publicId, 2*lesson.duration*60);

  // Send the lesson data, including the signed video URL
  res.status(200).json({
    success: true,
    data: {
      ...lesson.toObject(),
      videoUrl: signedVideoUrl, // Use the signed URL
    },
  });
});


// @desc Get all lessons for a specific course
// @route GET /api/v1/lessons/course/:courseId
export const getLessonsByCourse = catchAsync(async (req, res, next) => {
  const lessons = await Lesson.find({ course: req.params.courseId }).select("-videoUrl");

  res.status(200).json({
    success: true,
    count: lessons.length,
    data: lessons,
  });
});


// @desc Update a lesson
// @route PATCH /api/v1/lessons/:id
export const updateLesson = catchAsync(async (req, res, next) => {
  const { title, content, duration } = req.body;

  const lesson = await Lesson.findById(req.params.id).populate("course");
  if (!lesson) {
    return next(new AppError("Lesson not found", 404));
  }

  // Check if the user is an admin, instructor, or course creator
  if (!isAdmin(req.user) && !isInstructor(lesson.course, req.user.id) && !isCourseCreator(lesson.course, req.user.id)) {
    return next(new AppError("You are not authorized to update this lesson", 403));
  }

  // If a new video is uploaded
  if (req.file) {
    // Extract the public ID from the old video URL
    const oldVideoUrl = lesson.videoUrl;

    // Use regex to extract the public ID
    const publicIdMatch = oldVideoUrl.match(/upload\/v\d+\/(.*)\.mp4$/);
    if (!publicIdMatch) {
      return next(new AppError("Invalid video URL format", 400));
    }

    const publicId = publicIdMatch[1]; // Extracts the public ID without extension
    console.log(`Extracted Public ID for deletion: ${publicId}`);

    // Delete the old video from Cloudinary
    const deleteResponse = await cloudinary.uploader.destroy(publicId, { resource_type: 'video' });
    console.log('Delete response from Cloudinary:', deleteResponse); // Log the response for debugging

    // Extract the new video URL from the multer object
    const videoUrl = req.file.path;

    // Update the lesson's video URL
    lesson.videoUrl = videoUrl; // Update the lesson's videoUrl field
  }

  // Update the rest of the lesson information
  const updatedLesson = await Lesson.findByIdAndUpdate(
    req.params.id,
    { title, content, duration, videoUrl: lesson.videoUrl }, // Include the updated video URL
    { new: true, runValidators: true }
  );

  res.status(200).json({
    success: true,
    data: updatedLesson,
  });
});

// @desc Delete a lesson
// @route DELETE /api/v1/lessons/:id
export const deleteLesson = catchAsync(async (req, res, next) => {
  const lesson = await Lesson.findById(req.params.id).populate("course");

  if (!lesson) {
    return next(new AppError("Lesson not found", 404));
  }

  // Check if the user is an admin, instructor, or course creator
  if (!isAdmin(req.user) && !isInstructor(lesson.course, req.user.id) && !isCourseCreator(lesson.course, req.user.id)) {
    return next(new AppError("You are not authorized to delete this lesson", 403));
  }

  // Extract the public ID from the video URL
  const publicId = lesson.videoUrl
    .match(/upload\/v\d+\/(.*)\.mp4$/)[1]; // Extracts the public ID without extension

  console.log('Deleting video with public ID:', publicId); // Log public ID

  // Delete the video from Cloudinary
  const deleteResponse = await cloudinary.uploader.destroy(publicId, {
    resource_type: 'video',
  });

  // Check if the deletion was successful
  if (deleteResponse.result !== 'ok') {
    return next(new AppError("Error deleting video from Cloudinary", 500));
  }

  // Delete the lesson from the database
  await Lesson.findByIdAndDelete(req.params.id);

  // Remove the lesson reference from the course
  await Course.findByIdAndUpdate(
    lesson.course,
    { $pull: { lessons: lesson._id } },
    { new: true, runValidators: true }
  );

  res.status(204).json({
    success: true,
    data: null,
  });
});


// @desc Mark a lesson as completed
// @route PATCH /api/v1/lessons/:id/complete
export const completeLesson = catchAsync(async (req, res, next) => {
  const lesson = await Lesson.findById(req.params.id);
  if (!lesson) {
    return next(new AppError("Lesson not found", 404));
  }

  const courseId = lesson.course;

  const enrollment = await Enrollment.findOne({
    student: req.user.id,
    course: courseId,
  });

  if (!enrollment) {
    return next(new AppError("Enrollment not found", 404));
  }

  if (enrollment.completed_lessons.includes(req.params.id)) {
    return next(new AppError("Lesson already marked as completed", 400));
  }

  enrollment.completed_lessons.push(req.params.id);
  await enrollment.save();

  res.status(200).json({
    success: true,
    data: enrollment,
  });
});

File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/controllers/reviewController.js
import Review from "../models/Review.js";
import Course from "../models/Course.js";
import catchAsync from "../utils/catchAsync.js";
import AppError from "../utils/AppError.js";
import Enrollment from "../models/Enrollment.js";

// @desc Create a new review
// @route POST /api/v1/courses/:courseId/reviews or /api/v1/reviews
export const createReview = catchAsync(async (req, res, next) => {
  const { rating, review } = req.body;

  // Validate input
  if (!rating || rating < 1 || rating > 5) {
    return next(new AppError("Rating must be between 1 and 5", 400));
  }
  if (!review || review.trim() === '') {
    return next(new AppError("Review cannot be empty", 400));
  }

  // Ensure the course exists
  const filter = {
    _id: req.params.courseId ? req.params.courseId : req.body.course,
  };
  const course = await Course.findById(filter._id);
  if (!course) {
    return next(new AppError("Course not found", 404));
  }

  // Check if the user is enrolled in the course
  const isEnrolled = await Enrollment.findOne({
    student: req.user.id,
    course: filter._id,
  });

  if (!isEnrolled) {
    return next(new AppError("You must be enrolled in this course to leave a review", 403));
  }

  // Check for duplicate review
  const existingReview = await Review.findOne({
    user: req.user.id,
    course: filter._id,
  });

  if (existingReview) {
    return next(new AppError("You have already reviewed this course", 400));
  }

  // Create a review
  const newReview = await Review.create({
    review,
    rating,
    course: filter._id,
    user: req.user.id,
  });

  res.status(201).json({
    success: true,
    data: newReview,
  });
});


// @desc Get all reviews for a course
// @route GET /api/v1/courses/:courseId/reviews or /api/v1/reviews
export const getReviews = catchAsync(async (req, res, next) => {
  const filter = req.params.courseId ? { course: req.params.courseId } : {};
  
  const reviews = await Review.find(filter);

  res.status(200).json({
    success: true,
    count: reviews.length,
    data: reviews,
  });
});

// @desc Get a review by ID
// @route GET /api/v1/courses/:courseId/reviews/:id or /api/v1/reviews/:id
export const getReviewById = catchAsync(async (req, res, next) => {
  const filter = {
    _id: req.params.id,
  };

  const review = await Review.findById(filter._id);

  if (!review) {
    return next(new AppError("Review not found", 404));
  }

  res.status(200).json({
    success: true,
    data: review,
  });
});

// @desc Update a review
// @route PATCH /api/v1/courses/:courseId/reviews/:id or /api/v1/reviews/:id
export const updateReview = catchAsync(async (req, res, next) => {
  const { rating, review } = req.body;
  const reviewId = req.params.id;

  // Check if the review exists
  const existingReview = await Review.findById(reviewId);
  if (!existingReview) {
    return next(new AppError("Review not found", 404));
  }

  // Check if the user is allowed to update the review
  const isAdmin = req.user.role === "admin"; // Assuming `req.user.role` is set for authenticated users
  const isCreator = existingReview.user.toString() === req.user.id;

  if (!isAdmin && !isCreator) {
    return next(new AppError("You are not authorized to update this review", 403));
  }

  const updatedReview = await Review.findByIdAndUpdate(
    reviewId,
    { rating, review },
    { new: true, runValidators: true }
  );

  res.status(200).json({
    success: true,
    data: updatedReview,
  });
});

// @desc Delete a review
// @route DELETE /api/v1/courses/:courseId/reviews/:id or /api/v1/reviews/:id
export const deleteReview = catchAsync(async (req, res, next) => {
  const reviewId = req.params.id;

  // Check if the review exists
  const existingReview = await Review.findById(reviewId);
  if (!existingReview) {
    return next(new AppError("Review not found", 404));
  }

  // Check if the user is allowed to delete the review
  const isAdmin = req.user.role === "admin";
  const isCreator = existingReview.user.toString() === req.user.id;

  if (!isAdmin && !isCreator) {
    return next(new AppError("You are not authorized to delete this review", 403));
  }

  await Review.findByIdAndDelete(reviewId);

  res.status(204).json({
    success: true,
    data: null,
  });
});


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/controllers/userController.js
import catchAsync from "../utils/catchAsync.js";
import User from "../models/User.js";
import AppError from "../utils/AppError.js";
import bcrypt from "bcryptjs";
import Enrollment from "../models/Enrollment.js";
import Review from "../models/Review.js"; // Import the Review model

export const getAllUsers = catchAsync(async (req, res, next) => {
  const { role } = req.query;

  const query = role ? { role: { $regex: new RegExp(role, "i") } } : {};

  const users = await User.find(query).select("-__v");

  res.status(200).json({
    success: true,
    count: users.length,
    data: users,
  });
});

export const addUser = catchAsync(async (req, res, next) => {
  const { name, email, contact, role, password } = req.body;

  const newUser = await User.create({
    name,
    email,
    contact,
    role,
    password,
  });

  res.status(201).json({
    status: "success",
    data: {
      user: newUser,
    },
  });
});

export const updateUser = catchAsync(async (req, res, next) => {
  const { id } = req.params;
  const updates = req.body;

  if (updates.password) {
    updates.password = await bcrypt.hash(updates.password, 12);
  }

  const user = await User.findByIdAndUpdate(id, updates, {
    new: true,
    runValidators: true,
  });

  if (!user) {
    return next(new AppError("User not found", 404));
  }

  res.json({
    status: "success",
    data: {
      user,
    },
  });
});

export const deleteUser = catchAsync(async (req, res, next) => {
  const { id } = req.params;

  // Check if the user exists
  const user = await User.findById(id);
  if (!user) {
    return next(new AppError("User not found", 404));
  }

  // If the user is a student, delete their enrollments and reviews
  if (user.role === 'student') {
    await Enrollment.deleteMany({ student: id });
    await Review.deleteMany({ user: id });
  }

  // Delete the user
  await User.findByIdAndDelete(id);

  res.json({
    status: "success",
    message: "User deleted successfully",
  });
});

export const myInfoHandler = catchAsync(async (req, res, next) => {
  const user_id = req.user._id;

  const user = await User.findById(user_id).select("name email");

  if (!user) {
    return next(new AppError("User not found", 404));
  }

  const enrollments = await Enrollment.find({ student: user_id })
    .populate({
      path: "course",
      select: "title description instructors",
    })
    .populate({
      path: "completed_lessons",
      select: "title",
    });

  res.json({
    success: true,
    data: {
      user: {
        name: user.name,
        email: user.email,
      },
      enrollments,
    },
  });
});

export const userInfoHandler = catchAsync(async (req, res, next) => {
  const { id } = req.params;

  const user = await User.findById(id);

  if (!user) {
    return next(new AppError("User not found", 404));
  }

  const enrollments = await Enrollment.find({ student: id })
    .populate({
      path: "course",
      select: "title description instructors",
    })
    .populate({
      path: "completed_lessons",
      select: "title",
    });

  res.json({
    success: true,
    data: {
      user,
      enrollments,
    },
  });
});

export const updateMe = catchAsync(async (req, res, next) => {
  const { name, email, contact } = req.body;

  // Ensure no password is being updated here
  if (req.body.password) {
    return next(new AppError('This route is not for updating password. Please use /update-password', 400));
  }

  // Update the current user (exclude sensitive fields like password)
  const updatedUser = await User.findByIdAndUpdate(
    req.user.id,
    { name, email, contact },
    {
      new: true,
      runValidators: true,
    }
  );

  if (!updatedUser) {
    return next(new AppError('User not found', 404));
  }

  res.status(200).json({
    status: 'success',
    data: {
      user: updatedUser,
    },
  });
});

// Update the current user's password
export const updatePassword = catchAsync(async (req, res, next) => {
  const { currentPassword, newPassword, passwordConfirm } = req.body;

  // 1. Get the user from the database
  const user = await User.findById(req.user.id).select('+password');

  if (!user) {
    return next(new AppError('User not found', 404));
  }

  // 2. Check if the posted current password is correct
  const isCorrectPassword = await user.correctPassword(currentPassword, user.password);
  if (!isCorrectPassword) {
    return next(new AppError('Your current password is incorrect', 401));
  }

  // 3. Check if new password and passwordConfirm match
  if (newPassword !== passwordConfirm) {
    return next(new AppError('New password and confirm password do not match', 400));
  }

  // 4. If so, update the password
  user.password = newPassword;
  await user.save(); // use save(), not findByIdAndUpdate, to trigger pre-save middleware

  res.status(200).json({
    status: 'success',
    message: 'Password updated successfully',
  });
});


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/middleware/authMiddleware.js
import jwt from "jsonwebtoken";
import User from "../models/User.js";
import catchAsync from "../utils/catchAsync.js";
import AppError from "../utils/AppError.js";

const JWT_SECRET = process.env.JWT_SECRET;

export const protect = catchAsync(async (req, res, next) => {
  let token;

  if (
    req.headers.authorization &&
    req.headers.authorization.startsWith("Bearer")
  ) {
    token = req.headers.authorization.split(" ")[1];
  }

  if (!token) {
    return next(
      new AppError(
        "You are not logged in! Please log in to access this route.",
        401
      )
    );
  }

  const decoded = jwt.verify(token, JWT_SECRET);

  const currentUser = await User.findById(decoded.userId);
  if (!currentUser) {
    return next(
      new AppError("The user belonging to this token no longer exists.", 401)
    );
  }

  req.user = currentUser;
  next();
});

export const restrictTo = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return next(
        new AppError("You do not have permission to perform this action", 403)
      );
    }
    next();
  };
};


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/middleware/notFound.js
const notFound = (req, res) => {
  return res.status(404).json({
    status: 'fail',
    message: `Can't find ${req.originalUrl} on this server!`
  });
};

export default notFound;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/models/Course.js
import mongoose from "mongoose";
import User from "./User.js";

const courseSchema = new mongoose.Schema(
  {
    title: {
      type: String,
      required: [true, "A course must have a title"],
      minlength: [5, "A course title must have at least 5 characters"],
      maxlength: [100, "A course title must have less than 100 characters"],
    },
    description: {
      type: String,
      required: [true, "A course must have a description"],
      minlength: [20, "A course description must have at least 20 characters"],
    },
    instructors: [
      {
        _id: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "User",
          required: [true, "An instructor must have an ID"],
        },
        name: {
          type: String,
        },
      },
    ],
    category: {
      type: String,
      required: [true, "A course must have a category"],
    },
    lessons: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Lesson",
      },
    ],
    rating: {
      type: Number,
      default: 0,
      min: [0, "Rating must be at least 0"],
      max: [5, "Rating must be at most 5"],
      set: function (value) {
        return Math.round(value * 10) / 10;
      },
    },
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: [true, "A course must have a creator"],
    },
    price: {
      type: Number,
      required: [true, "A course must have a price"],
      min: [0, "Price must be at least 0"],
    },
  },
  {
    timestamps: true,
  }
);

courseSchema.pre("save", async function (next) {
  if (this.isModified("instructors") || this.isNew) {
    this.instructors = await Promise.all(
      this.instructors.map(async (instructor) => {
        const user = await User.findById(instructor._id);
        if (!user) {
          throw new Error(`Instructor with ID ${instructor._id} not found`);
        }
        return {
          _id: user._id,
          name: user.name,
        };
      })
    );
  }
  next();
});

const Course = mongoose.model("Course", courseSchema);

export default Course;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/models/Enrollment.js
import mongoose from "mongoose";
import Course from "./Course.js";

const enrollmentSchema = new mongoose.Schema(
  {
    student: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    course: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Course",
      required: true,
    },
    enrollment_date: {
      type: Date,
      default: Date.now,
    },
    progress: {
      type: Number,
      default: 0,
      min: [0, "Progress cannot be less than 0%"],
      max: [100, "Progress cannot be more than 100%"],
    },
    completed_lessons: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Lesson",
      },
    ],
  },
  {
    timestamps: true,
  }
);

enrollmentSchema.pre("save", async function (next) {
  const enrollment = this;

  const course = await Course.findById(enrollment.course).populate("lessons");

  if (course.lessons.length > 0) {
    enrollment.progress =
      (enrollment.completed_lessons.length / course.lessons.length) * 100;
  } else {
    enrollment.progress = 0;
  }
  next();
});

const Enrollment = mongoose.model("Enrollment", enrollmentSchema);

export default Enrollment;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/models/Lesson.js
import mongoose from 'mongoose';

const lessonSchema = new mongoose.Schema({
  title: {
    type: String,
    required: [true, "A lesson must have a title"],
  },
  content: {
    type: String,
    required: [true, "A lesson must have content"],
  },
  duration: {
    type: Number,
    required: [true, "A lesson must have a duration"],
    min: [1, "Duration must be at least 1 minute"],
  },
  videoUrl: {
    type: String, // URL to the video stored in Cloudinary
    required: true,
  },
  course: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Course',
    required: [true, "A lesson must belong to a course"],
  }
}, {
  timestamps: true 
});

const Lesson = mongoose.model('Lesson', lessonSchema);

export default Lesson;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/models/Review.js
import mongoose from "mongoose";
import Course from "./Course.js";

const reviewSchema = new mongoose.Schema(
  {
    review: {
      type: String,
      required: [true, "Review cannot be empty"],
    },
    rating: {
      type: Number,
      min: [1, "Rating must be above 1.0"],
      max: [5, "Rating must be below 5.0"],
      required: [true, "A rating is required"],
    },
    course: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Course",
      required: [true, "Review must belong to a course"],
    },
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: [true, "Review must belong to a user"],
    },
  },
  {
    timestamps: true,
  },
  {
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

reviewSchema.index({ user: 1, course: 1 }, { unique: true });

const calculateAverageRating = async function (courseId) {
  const reviews = await mongoose.model("Review").find({ course: courseId });
  const totalReviews = reviews.length;

  if (totalReviews > 0) {
    const totalRating = reviews.reduce((acc, review) => acc + review.rating, 0);
    const averageRating = totalRating / totalReviews;

    await Course.findByIdAndUpdate(courseId, {
      rating: Math.round(averageRating * 10) / 10,
    });
  } else {
    await Course.findByIdAndUpdate(courseId, { rating: 0 });
  }
};

reviewSchema.post("save", async function (doc) {
  await calculateAverageRating(doc.course);
});

reviewSchema.post("findOneAndUpdate", async function (doc) {
  if (doc) {
    await calculateAverageRating(doc.course);
  }
});

reviewSchema.pre("findOneAndDelete", async function (next) {
  const review = await this.model.findOne(this.getQuery());

  if (review) {
    const course = await Course.findById(review.course);
    if (course) {
      const Review = mongoose.model("Review");

      const result = await Review.aggregate([
        { $match: { course: course._id, _id: { $ne: review._id } } },
        { $group: { _id: "$course", averageRating: { $avg: "$rating" } } },
      ]);

      course.rating = result.length > 0 ? Math.round(result[0].averageRating * 10) / 10 : 0;

      await course.save();
    }
  }
  next();
});

const Review = mongoose.model("Review", reviewSchema);

export default Review;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/models/User.js
import mongoose from "mongoose";
import validator from "validator";
import bcrypt from "bcryptjs";
import crypto from "crypto"; // Import crypto for token generation

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, "Name is required"],
    trim: true,
    minlength: [2, "Name must be at least 2 characters long"],
    maxlength: [50, "Name must be less than 50 characters"],
    lowercase: true,
  },
  email: {
    type: String,
    required: [true, "Email is required"],
    unique: true,
    lowercase: true,
    trim: true,
    validate: [validator.isEmail, "Please provide a valid email address"],
  },
  contact: {
    type: String,
    required: [true, "Contact number is required"],
    match: [/^\d{10}$/, "Contact number must be a valid 10-digit number"],
    unique: true,
  },
  role: {
    type: String,
    enum: ["admin", "student", "instructor"],
    default: "student",
    required: [true, "Role is required"],
  },
  passwordResetToken: String,
  passwordResetExpires: Date,
  passwordResetAttempts: {
    type: Number,
    default: 0, // Initialize to 0 to track the number of attempts
  },
  password: {
    type: String,
    required: [true, "Password is required"],
    minlength: [8, "Password must be at least 8 characters long"],
    select: false,
  },
}, {
  timestamps: true,
});

// Pre-save hook to hash the password
userSchema.pre("save", async function (next) {
  if (!this.isModified("password")) return next();
  this.password = await bcrypt.hash(this.password, 12);
  next();
});

// Method to generate a password reset token
userSchema.methods.createPasswordResetToken = function () {
  // Generate a random token
  const resetToken = crypto.randomBytes(32).toString("hex");

  // Hash the token and set the values to the user's fields
  this.passwordResetToken = crypto.createHash("sha256").update(resetToken).digest("hex");
  this.passwordResetExpires = Date.now() + 10 * 60 * 1000; // 10 minutes

  return resetToken; // Return the un-hashed token for sending in the email
};

// Method to check if the reset token is valid
userSchema.methods.isResetTokenValid = function (candidateToken) {
  const hashedToken = crypto.createHash("sha256").update(candidateToken).digest("hex");
  return this.passwordResetToken === hashedToken && this.passwordResetExpires > Date.now();
};

// Method to check the password
userSchema.methods.correctPassword = async function (candidatePassword, userPassword) {
  return await bcrypt.compare(candidatePassword, userPassword);
};

// Reset the password reset attempts after a successful reset
userSchema.methods.resetPasswordAttempts = function () {
  this.passwordResetAttempts = 0;
};

// Increment password reset attempts
userSchema.methods.incrementPasswordResetAttempts = function () {
  this.passwordResetAttempts += 1;
};

const User = mongoose.model("User", userSchema);

export default User;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/package.json
{
  "name": "academixhub",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "nodemon  --env-file=.env server.js",
    "start:prod": "node --env-file=.env server.js"
  },
  "type": "module",
  "license": "ISC",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cloudinary": "^1.41.3",
    "compression": "^1.7.4",
    "cors": "^2.8.5",
    "express": "^4.21.0",
    "express-mongo-sanitize": "^2.2.0",
    "express-rate-limit": "^7.4.1",
    "helmet": "^8.0.0",
    "hpp": "^0.2.3",
    "jsonwebtoken": "^9.0.2",
    "mongodb": "^6.9.0",
    "mongoose": "^8.7.1",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "multer-storage-cloudinary": "^4.0.0",
    "nodemailer": "^6.9.15",
    "sib-api-v3-sdk": "^8.5.0",
    "validator": "^13.12.0",
    "winston": "^3.15.0",
    "xss-clean": "^0.1.4"
  },
  "devDependencies": {
    "nodemon": "^3.1.7"
  }
}


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/README.md
# AcademixHub

File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/routes/authRoutes.js
// routes/authRoutes.js
import express from "express";
import { login, signup, forgotPassword, resetPassword } from "../controllers/authController.js";

const router = express.Router();

router.post("/signup", signup);
router.post("/login", login);
router.post("/forgotPassword", forgotPassword); // Add this route
router.post("/resetPassword", resetPassword); // Add this route

export default router;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/routes/courseRoutes.js
import express from "express";
import {
  createCourse,
  deleteCourse,
  getCourseById,
  getCourses,
  updateCourse,
} from "../controllers/courseController.js";
import { protect, restrictTo } from "../middleware/authMiddleware.js";
import reviewRouter from "./reviewRoutes.js";

const router = express.Router();

router.use("/:courseId/reviews", reviewRouter);

router.get("/", getCourses);

router.get("/:id", getCourseById);

router.use(protect, restrictTo("admin", "instructor"));

router.post("/", createCourse);

router.patch("/:id", updateCourse);

router.delete("/:id", deleteCourse);

export default router;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/routes/enrollmentRoutes.js
import express from "express";
import { protect, restrictTo } from "../middleware/authMiddleware.js";
import {
  enrollInCourse,
  getEnrollmentsByCourse,
  deleteEnrollment,
  getEnrollmentById,
  getEnrollmentsByStudent,
} from "../controllers/enrollmentController.js";

const router = express.Router();

router.use(protect);

router.post("/", restrictTo("student"), enrollInCourse);

router.get(
  "/course/:courseId",
  restrictTo("admin", "instructor"),
  getEnrollmentsByCourse
);

router.use(restrictTo("admin"));

router.get("/student/:studentId", getEnrollmentsByStudent);
router.delete("/:id", deleteEnrollment);
router.get("/:id", getEnrollmentById);

export default router;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/routes/lessonRoutes.js
import express from "express";
import {
  createLesson,
  getLessonsByCourse,
  getLessonById,
  updateLesson,
  deleteLesson,
  completeLesson,
} from "../controllers/lessonController.js";
import { protect, restrictTo } from "../middleware/authMiddleware.js";
import upload from "../utils/multerConfig.js";

const router = express.Router();

router.use(protect);

router.get("/course/:courseId", getLessonsByCourse);

router.get("/:id", getLessonById);

router.patch("/:id/complete", restrictTo("student"), completeLesson);

router.use(restrictTo("admin", "instructor"));

router.post("/", upload.single("video"), createLesson);
router.patch('/:id', upload.single("video"), updateLesson); 

router.delete("/:id", deleteLesson);

export default router;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/routes/reviewRoutes.js
import express from "express";
import {
  createReview,
  getReviews,
  updateReview,
  deleteReview,
  getReviewById
} from "../controllers/reviewController.js";
import { protect, restrictTo } from "../middleware/authMiddleware.js";

const router = express.Router({ mergeParams: true });

router.use(protect);

router.post("/", restrictTo("student"), createReview);

router.get("/", getReviews);

router.get("/:id", getReviewById);

router.use(restrictTo("admin","student"));

router
  .route("/:id")
  .patch( updateReview)
  .delete(deleteReview);

export default router;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/routes/userRoutes.js
import express from "express";
import { protect, restrictTo } from "../middleware/authMiddleware.js";
import {
  addUser,
  deleteUser,
  getAllUsers,
  myInfoHandler,
  updateMe,
  updatePassword,
  updateUser,
  userInfoHandler,
} from "../controllers/userController.js";

const router = express.Router();

router.use(protect);

router.get("/myInfo", myInfoHandler);
router.patch("/updateMe", updateMe);
router.patch("/updatePassword", updatePassword);

router.use(restrictTo("admin"));

router.get("/", getAllUsers);
router.post("/", addUser);
router.patch("/:id", updateUser);
router.delete("/:id", deleteUser);
router.get("/:id", userInfoHandler);

export default router;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/scripts/codeExtractor.txt
$ find . -type f -exec sh -c 'echo "File: $(realpath {})" >> output.txt; cat {} >> output.txt; echo -e "\n" >> output.txt' \;


find . -type f ! -path './node_modules/*' ! -path './.git/*' ! -name 'package-lock.json' -exec sh -c 'echo "File: $(realpath {})" >> output.txt; cat {} >> output.txt; echo -e "\n" >> output.txt' \;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/scripts/projectStructureExtractor.txt
find . \( -name "node_modules" -o -name ".git" \) -prune -o -print > folder_structure.txt


find . \( -name "node_modules" -o -name ".git" \) -prune -o -print


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/server.js
import app from "./app.js"; // Import your Express app
import mongoose from "mongoose";

const PORT = process.env.PORT || 3000;
const DB_STRING = process.env.DB_STRING?.replace("<db_password>", process.env.DB_PASSWORD);

if (!DB_STRING) {
  console.error("Database connection string must be set.");
  process.exit(1);
}

// Function to connect to MongoDB
const connectDB = async () => {
  try {
    await mongoose.connect(DB_STRING);
    console.log("Connected to MongoDB");
  } catch (error) {
    console.error("Error connecting to MongoDB:", error);
    process.exit(1);
  }
};

// Start the server
const startServer = async () => {
  await connectDB();
  const server = app.listen(PORT, () => {
    console.log(`Server is running on PORT ${PORT}`);
  });

  // Graceful shutdown
  const gracefulShutdown = async (signal) => {
    console.log(`Received ${signal}. Shutting down...`);
    server.close(async () => {
      await mongoose.connection.close();
      console.log("MongoDB connection closed.");
      process.exit(0);
    });
  };

  // Handle termination signals
  process.on("SIGINT", () => gracefulShutdown("SIGINT"));
  process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));

  // Handle unhandled promise rejections and uncaught exceptions
  process.on("unhandledRejection", (error) => {
    console.error("Unhandled promise rejection:", error);
    gracefulShutdown("Unhandled promise rejection");
  });

  process.on("uncaughtException", (error) => {
    console.error("Uncaught exception:", error);
    gracefulShutdown("Uncaught exception");
  });
};

// Start the application
startServer();


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/utils/AppError.js
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith("4") ? "fail" : "error";
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

export default AppError;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/utils/catchAsync.js
const catchAsync = (fn) => (req, res, next) => {
  fn(req, res, next).catch(next);
};

export default catchAsync;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/utils/emailService.js
import SibApiV3Sdk from 'sib-api-v3-sdk';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the __dirname equivalent in ES6
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Initialize Brevo client with your API key
const client = SibApiV3Sdk.ApiClient.instance;
client.authentications['api-key'].apiKey = process.env.BREVO_API_KEY; // Ensure this is in your environment variables

// Function to send a welcome email when a user signs up
export const sendWelcomeEmail = async (email, username) => {
  const emailApi = new SibApiV3Sdk.TransactionalEmailsApi();
  
  // Read the welcome email HTML template
  const templatePath = path.join(__dirname, 'templates', 'welcomeEmail.html');
  let htmlContent;
  try {
    htmlContent = fs.readFileSync(templatePath, 'utf-8');
  } catch (error) {
    console.error('Error reading the email template:', error);
    throw new Error('Failed to read email template');
  }

  // Replace placeholders in the template with actual values
  htmlContent = htmlContent
    .replace('{{username}}', username)
    .replace('{{year}}', new Date().getFullYear());

  const mailOptions = {
    sender: { email: process.env.EMAIL_USERNAME, name: 'Team Academixhub' },
    to: [{ email, name: username }],
    subject: 'Welcome to Our Platform!',
    htmlContent: htmlContent,
  };

  try {
    const info = await emailApi.sendTransacEmail(mailOptions);
    console.log('Welcome email sent successfully:', info);
  } catch (error) {
    console.error('Error sending welcome email:', error);
    throw new Error('Failed to send welcome email');
  }
};

// Function to send an enrollment confirmation email when a student enrolls in a course
export const sendEnrollmentEmail = async (email, courseName, courseId, studentName) => {
  const emailApi = new SibApiV3Sdk.TransactionalEmailsApi();

  const templatePath = path.join(__dirname, 'templates', 'enrollmentEmail.html');
  let htmlContent;
  try {
    htmlContent = fs.readFileSync(templatePath, 'utf-8');
  } catch (error) {
    console.error('Error reading the email template:', error);
    throw new Error('Failed to read email template');
  }

  const year = new Date().getFullYear();
  htmlContent = htmlContent
    .replace('{{studentName}}', studentName)
    .replace('{{courseName}}', courseName)
    .replace('{{courseId}}', courseId)
    .replace('{{year}}', year);

  const mailOptions = {
    sender: { email: process.env.EMAIL_USERNAME, name: 'Team Academixhub' },
    to: [{ email, name: studentName }],
    subject: `Enrollment Confirmation for ${courseName}`,
    htmlContent: htmlContent,
  };

  try {
    const info = await emailApi.sendTransacEmail(mailOptions);
    console.log('Enrollment email sent successfully:', info);
  } catch (error) {
    console.error('Error sending enrollment email:', error);
    throw new Error('Failed to send enrollment email');
  }
};

// Function to send a password reset email
export const sendResetPasswordEmail = async (email, resetUrl) => {
  const emailApi = new SibApiV3Sdk.TransactionalEmailsApi();

  // Read the reset password email HTML template
  const templatePath = path.join(__dirname, 'templates', 'resetPasswordEmail.html');
  let htmlContent;
  try {
      htmlContent = fs.readFileSync(templatePath, 'utf-8');
  } catch (error) {
      console.error('Error reading the email template:', error);
      throw new Error('Failed to read email template');
  }

  // Replace placeholders in the template with actual values
  const year = new Date().getFullYear();
  htmlContent = htmlContent
      .replace('{{resetUrl}}', resetUrl) // Insert the reset URL
      .replace('{{year}}', year); // Insert the current year

  const mailOptions = {
      sender: { email: process.env.EMAIL_USERNAME, name: 'Team Academixhub' },
      to: [{ email }],
      subject: 'Password Reset Instructions',
      htmlContent: htmlContent, // Use the loaded HTML template
  };

  try {
      await emailApi.sendTransacEmail(mailOptions);
      console.log('Reset password email sent successfully');
  } catch (error) {
      console.error('Error sending reset password email:', error);
      throw new Error('Failed to send reset password email');
  }
};


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/utils/errorHandler.js
const globalErrorHandler = (err, req, res, next) => {
  err.statusCode = err.statusCode || 500;
  err.status = err.status || "error";

  res.status(err.statusCode).json({
    success: false,
    status: err.status,
    message: err.message,
    stack: process.env.NODE_ENV === "development" ? err.stack : undefined,
  });
};

export default globalErrorHandler;


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/utils/multerConfig.js
import multer from 'multer';
import { CloudinaryStorage } from 'multer-storage-cloudinary';
import cloudinary from '../config/cloudinary.js';

// Configure Cloudinary storage
const storage = new CloudinaryStorage({
  cloudinary,
  params: {
    folder: 'academixhub/videos', // Folder in Cloudinary
    resource_type: 'video',       // Specify resource type as 'video'
  },
});

const upload = multer({ storage });

export default upload;

File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/utils/templates/enrollmentEmail.html
<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      font-family: Arial, sans-serif;  
      background-color: #f9f9f9;
      color: #333;
      margin: 0;
      padding: 20px;
    }
    .container {
      max-width: 600px;
      margin: auto;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
    }
    h1 {
      color: #4CAF50;
      text-align: center;
    }
    p {
      line-height: 1.6;
      font-size: 16px;
    }
    .footer {
      margin-top: 20px;
      text-align: center;
      font-size: 12px;
      color: #777;
    }
    .button {
      display: inline-block;
      padding: 10px 20px;
      color: #fff;
      background-color: #4CAF50;
      text-decoration: none;
      border-radius: 5px;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Congratulations, {{studentName}}!</h1>
    <p>You have successfully enrolled in the course <strong>{{courseName}}</strong>.</p>
    <p>We're excited for you to start learning and growing your skills!</p>
    <p>Click the button below to access your course dashboard:</p>
    <a href="https://academixhub.onrender.com/api/v1/courses/{{courseId}}" class="button">Go to Course</a>
    <p>Best Regards,<br>Team Academixhub</p>
  </div>
  <div class="footer">
    <p>&copy; {{year}} Academixhub. All rights reserved.</p>
  </div>
</body>
</html>


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/utils/templates/resetPasswordEmail.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Password Reset Instructions</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #e9f5ff; /* Light blue background */
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 600px;
            margin: auto;
            background: #ffffff; /* White background for content */
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid #d1e7dd; /* Soft green border */
        }
        h1 {
            color: #0d6efd; /* Bootstrap primary blue */
            font-size: 28px;
            margin-bottom: 10px;
            text-align: center;
        }
        p {
            line-height: 1.6;
            color: #343a40; /* Dark gray text */
            margin-bottom: 20px;
            font-size: 16px;
        }
        a {
            display: inline-block;
            padding: 12px 20px;
            background-color: #198754; /* Bootstrap success green */
            color: white;
            text-decoration: none;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }
        a:hover {
            background-color: #145a32; /* Darker green on hover */
        }
        footer {
            margin-top: 30px;
            font-size: 14px;
            color: #6c757d; /* Light gray for footer */
            text-align: center;
        }
        /* Responsive styles */
        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            h1 {
                font-size: 24px;
            }
            p {
                font-size: 14px;
            }
            a {
                padding: 10px 15px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Password Reset Instructions</h1>
        <p>You requested a password reset for your account. Please click the link below to set a new password:</p>
        <p>
            <a href="{{resetUrl}}">Reset Your Password</a>
        </p>
        <p>If you did not request this change, you can safely ignore this email.</p>
        <footer>
            <p>&copy; {{year}} Team Academixhub. All rights reserved.</p>
        </footer>
    </div>
</body>
</html>


File: /d/Downloads/desktop se laya hun/Important Study Material/AcademixHub/utils/templates/welcomeEmail.html
<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f9f9f9;
      color: #333;
      margin: 0;
      padding: 20px;
    }
    .container {
      max-width: 600px;
      margin: auto;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
    }
    h1 {
      color: #4CAF50;
      text-align: center;
    }
    p {
      line-height: 1.6;
      font-size: 16px;
    }
    .footer {
      margin-top: 20px;
      text-align: center;
      font-size: 12px;
      color: #777;
    }
    .button {
      display: inline-block;
      padding: 10px 20px;
      color: #fff;
      background-color: #4CAF50;
      text-decoration: none;
      border-radius: 5px;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Welcome, {{username}}!</h1>
    <p>We're excited to have you on board. Enjoy exploring all the features our platform has to offer!</p>
    <p>To get started, click the button below:</p>
    <a href="https://academixhub.onrender.com" class="button">Get Started</a>
    <p>Best Regards,<br>Team Academixhub</p>
  </div>
  <div class="footer">
    <p>&copy; {{year}} Academixhub. All rights reserved.</p>
  </div>
</body>
</html>


